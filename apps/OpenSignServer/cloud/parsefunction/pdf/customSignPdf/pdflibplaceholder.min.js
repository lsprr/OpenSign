import {
  DEFAULT_BYTE_RANGE_PLACEHOLDER,
  DEFAULT_SIGNATURE_LENGTH,
  SUBFILTER_ADOBE_PKCS7_DETACHED,
} from './const.min.js';
import { SignPdfError } from './SignPdfError.min.js';
import {
  PDFArray,
  PDFDict,
  PDFHexString,
  PDFName,
  PDFNumber,
  PDFInvalidObject,
  PDFString,
} from 'pdf-lib';
const pdflibAddPlaceholder = ({
  pdfDoc: e = void 0,
  pdfPage: o = void 0,
  reason: t,
  contactInfo: r = 'emailfromp1289@gmail.com',
  name: i = 'Name from p12',
  location: n,
  signingTime: a = void 0,
  signatureLength: P = DEFAULT_SIGNATURE_LENGTH,
  byteRangePlaceholder: F = DEFAULT_BYTE_RANGE_PLACEHOLDER,
  subFilter: D = SUBFILTER_ADOBE_PKCS7_DETACHED,
  widgetRect: f = [0, 0, 0, 0],
  appName: g = void 0,
}) => {
  if (void 0 === e && void 0 === o)
    throw new SignPdfError('PDFDoc or PDFPage must be set.', SignPdfError.TYPE_INPUT);
  var e = e ?? o.doc,
    o = o ?? e.getPages()[0],
    m = PDFArray.withContext(e.context),
    F =
      (m.push(PDFNumber.of(0)),
      m.push(PDFName.of(F)),
      m.push(PDFName.of(F)),
      m.push(PDFName.of(F)),
      PDFHexString.of(String.fromCharCode(0).repeat(P))),
    P = g ? { App: { Name: g } } : {},
    g = e.context.obj({
      Type: 'Sig',
      Filter: 'Adobe.PPKLite',
      SubFilter: D,
      ByteRange: m,
      Contents: F,
      Reason: PDFString.of(t),
      M: PDFString.fromDate(a ?? new Date()),
      ContactInfo: PDFString.of(r),
      Name: PDFString.of(i),
      Location: PDFString.of(n),
      Prop_Build: { Filter: { Name: 'Adobe.PPKLite' }, ...P },
    }),
    D = new Uint8Array(g.sizeInBytes()),
    m = (g.copyBytesInto(D, 0), PDFInvalidObject.of(D)),
    F = e.context.register(m);
  const s = PDFArray.withContext(e.context);
  f.forEach(e => s.push(PDFNumber.of(e)));
  (t = e.context.formXObject([], { BBox: f, Resources: {} })),
    (a = e.context.obj({
      Type: 'Annot',
      Subtype: 'Widget',
      FT: 'Sig',
      Rect: s,
      V: F,
      T: PDFString.of('Signature1'),
      F: 4,
      P: o.ref,
      AP: { N: e.context.register(t) },
    })),
    (r = e.context.register(a));
  let c = o.node.lookupMaybe(PDFName.of('Annots'), PDFArray),
    d =
      ((c = void 0 === c ? e.context.obj([]) : c).push(r),
      o.node.set(PDFName.of('Annots'), c),
      e.catalog.lookupMaybe(PDFName.of('AcroForm'), PDFDict));
  void 0 === d &&
    ((d = e.context.obj({ Fields: [] })),
    (i = e.context.register(d)),
    e.catalog.set(PDFName.of('AcroForm'), i));
  let N;
  N = d.has(PDFName.of('SigFlags')) ? d.get(PDFName.of('SigFlags')) : PDFNumber.of(0);
  n = PDFNumber.of(3 | N.asNumber());
  d.set(PDFName.of('SigFlags'), n), d.get(PDFName.of('Fields')).push(r);
};
export { pdflibAddPlaceholder };
